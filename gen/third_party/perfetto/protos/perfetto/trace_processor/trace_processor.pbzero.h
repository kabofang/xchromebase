// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROCESSOR_TRACE_PROCESSOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROCESSOR_TRACE_PROCESSOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AppendTraceDataResult;
class ComputeMetricArgs;
class ComputeMetricResult;
class DescriptorProto;
class DescriptorSet;
class DisableAndReadMetatraceResult;
class QueryArgs;
class QueryResult;
class QueryResult_CellsBatch;
class RawQueryArgs;
class RawQueryResult;
class RawQueryResult_ColumnDesc;
class RawQueryResult_ColumnValues;
class StatusResult;
class TraceProcessorRpc;
enum ComputeMetricArgs_ResultFormat : int32_t;
enum QueryResult_CellsBatch_CellType : int32_t;
enum RawQueryResult_ColumnDesc_Type : int32_t;
enum TraceProcessorRpc_TraceProcessorMethod : int32_t;

enum TraceProcessorApiVersion : int32_t {
  TRACE_PROCESSOR_CURRENT_API_VERSION = 5,
};

const TraceProcessorApiVersion TraceProcessorApiVersion_MIN = TRACE_PROCESSOR_CURRENT_API_VERSION;
const TraceProcessorApiVersion TraceProcessorApiVersion_MAX = TRACE_PROCESSOR_CURRENT_API_VERSION;

enum ComputeMetricArgs_ResultFormat : int32_t {
  ComputeMetricArgs_ResultFormat_BINARY_PROTOBUF = 0,
  ComputeMetricArgs_ResultFormat_TEXTPROTO = 1,
};

const ComputeMetricArgs_ResultFormat ComputeMetricArgs_ResultFormat_MIN = ComputeMetricArgs_ResultFormat_BINARY_PROTOBUF;
const ComputeMetricArgs_ResultFormat ComputeMetricArgs_ResultFormat_MAX = ComputeMetricArgs_ResultFormat_TEXTPROTO;

enum QueryResult_CellsBatch_CellType : int32_t {
  QueryResult_CellsBatch_CellType_CELL_INVALID = 0,
  QueryResult_CellsBatch_CellType_CELL_NULL = 1,
  QueryResult_CellsBatch_CellType_CELL_VARINT = 2,
  QueryResult_CellsBatch_CellType_CELL_FLOAT64 = 3,
  QueryResult_CellsBatch_CellType_CELL_STRING = 4,
  QueryResult_CellsBatch_CellType_CELL_BLOB = 5,
};

const QueryResult_CellsBatch_CellType QueryResult_CellsBatch_CellType_MIN = QueryResult_CellsBatch_CellType_CELL_INVALID;
const QueryResult_CellsBatch_CellType QueryResult_CellsBatch_CellType_MAX = QueryResult_CellsBatch_CellType_CELL_BLOB;

enum RawQueryResult_ColumnDesc_Type : int32_t {
  RawQueryResult_ColumnDesc_Type_UNKNOWN = 0,
  RawQueryResult_ColumnDesc_Type_LONG = 1,
  RawQueryResult_ColumnDesc_Type_DOUBLE = 2,
  RawQueryResult_ColumnDesc_Type_STRING = 3,
};

const RawQueryResult_ColumnDesc_Type RawQueryResult_ColumnDesc_Type_MIN = RawQueryResult_ColumnDesc_Type_UNKNOWN;
const RawQueryResult_ColumnDesc_Type RawQueryResult_ColumnDesc_Type_MAX = RawQueryResult_ColumnDesc_Type_STRING;

enum TraceProcessorRpc_TraceProcessorMethod : int32_t {
  TraceProcessorRpc_TraceProcessorMethod_TPM_UNSPECIFIED = 0,
  TraceProcessorRpc_TraceProcessorMethod_TPM_APPEND_TRACE_DATA = 1,
  TraceProcessorRpc_TraceProcessorMethod_TPM_FINALIZE_TRACE_DATA = 2,
  TraceProcessorRpc_TraceProcessorMethod_TPM_QUERY_STREAMING = 3,
  TraceProcessorRpc_TraceProcessorMethod_TPM_QUERY_RAW_DEPRECATED = 4,
  TraceProcessorRpc_TraceProcessorMethod_TPM_COMPUTE_METRIC = 5,
  TraceProcessorRpc_TraceProcessorMethod_TPM_GET_METRIC_DESCRIPTORS = 6,
  TraceProcessorRpc_TraceProcessorMethod_TPM_RESTORE_INITIAL_TABLES = 7,
  TraceProcessorRpc_TraceProcessorMethod_TPM_ENABLE_METATRACE = 8,
  TraceProcessorRpc_TraceProcessorMethod_TPM_DISABLE_AND_READ_METATRACE = 9,
  TraceProcessorRpc_TraceProcessorMethod_TPM_GET_STATUS = 10,
};

const TraceProcessorRpc_TraceProcessorMethod TraceProcessorRpc_TraceProcessorMethod_MIN = TraceProcessorRpc_TraceProcessorMethod_TPM_UNSPECIFIED;
const TraceProcessorRpc_TraceProcessorMethod TraceProcessorRpc_TraceProcessorMethod_MAX = TraceProcessorRpc_TraceProcessorMethod_TPM_GET_STATUS;

class DescriptorSet_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  DescriptorSet_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DescriptorSet_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DescriptorSet_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_descriptors() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> descriptors() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class DescriptorSet : public ::protozero::Message {
 public:
  using Decoder = DescriptorSet_Decoder;
  enum : int32_t {
    kDescriptorsFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DescriptorSet"; }


  using FieldMetadata_Descriptors =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DescriptorProto,
      DescriptorSet>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Descriptors kDescriptors() { return {}; }
  template <typename T = DescriptorProto> T* add_descriptors() {
    return BeginNestedMessage<T>(1);
  }

};

class DisableAndReadMetatraceResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DisableAndReadMetatraceResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DisableAndReadMetatraceResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DisableAndReadMetatraceResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_metatrace() const { return at<1>().valid(); }
  ::protozero::ConstBytes metatrace() const { return at<1>().as_bytes(); }
  bool has_error() const { return at<2>().valid(); }
  ::protozero::ConstChars error() const { return at<2>().as_string(); }
};

class DisableAndReadMetatraceResult : public ::protozero::Message {
 public:
  using Decoder = DisableAndReadMetatraceResult_Decoder;
  enum : int32_t {
    kMetatraceFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DisableAndReadMetatraceResult"; }


  using FieldMetadata_Metatrace =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      DisableAndReadMetatraceResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Metatrace kMetatrace() { return {}; }
  void set_metatrace(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Metatrace::kFieldId, data, size);
  }
  void set_metatrace(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Metatrace::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Error =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DisableAndReadMetatraceResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Error kError() { return {}; }
  void set_error(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Error::kFieldId, data, size);
  }
  void set_error(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Error::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class DisableAndReadMetatraceArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DisableAndReadMetatraceArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DisableAndReadMetatraceArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DisableAndReadMetatraceArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class DisableAndReadMetatraceArgs : public ::protozero::Message {
 public:
  using Decoder = DisableAndReadMetatraceArgs_Decoder;
  static constexpr const char* GetName() { return ".perfetto.protos.DisableAndReadMetatraceArgs"; }

};

class EnableMetatraceResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EnableMetatraceResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EnableMetatraceResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EnableMetatraceResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class EnableMetatraceResult : public ::protozero::Message {
 public:
  using Decoder = EnableMetatraceResult_Decoder;
  static constexpr const char* GetName() { return ".perfetto.protos.EnableMetatraceResult"; }

};

class EnableMetatraceArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EnableMetatraceArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EnableMetatraceArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EnableMetatraceArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class EnableMetatraceArgs : public ::protozero::Message {
 public:
  using Decoder = EnableMetatraceArgs_Decoder;
  static constexpr const char* GetName() { return ".perfetto.protos.EnableMetatraceArgs"; }

};

class ComputeMetricResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ComputeMetricResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ComputeMetricResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ComputeMetricResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_metrics() const { return at<1>().valid(); }
  ::protozero::ConstBytes metrics() const { return at<1>().as_bytes(); }
  bool has_metrics_as_prototext() const { return at<3>().valid(); }
  ::protozero::ConstChars metrics_as_prototext() const { return at<3>().as_string(); }
  bool has_error() const { return at<2>().valid(); }
  ::protozero::ConstChars error() const { return at<2>().as_string(); }
};

class ComputeMetricResult : public ::protozero::Message {
 public:
  using Decoder = ComputeMetricResult_Decoder;
  enum : int32_t {
    kMetricsFieldNumber = 1,
    kMetricsAsPrototextFieldNumber = 3,
    kErrorFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ComputeMetricResult"; }


  using FieldMetadata_Metrics =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      ComputeMetricResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Metrics kMetrics() { return {}; }
  void set_metrics(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_Metrics::kFieldId, data, size);
  }
  void set_metrics(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Metrics::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MetricsAsPrototext =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ComputeMetricResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MetricsAsPrototext kMetricsAsPrototext() { return {}; }
  void set_metrics_as_prototext(const char* data, size_t size) {
    AppendBytes(FieldMetadata_MetricsAsPrototext::kFieldId, data, size);
  }
  void set_metrics_as_prototext(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_MetricsAsPrototext::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Error =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ComputeMetricResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Error kError() { return {}; }
  void set_error(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Error::kFieldId, data, size);
  }
  void set_error(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Error::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class ComputeMetricArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ComputeMetricArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ComputeMetricArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ComputeMetricArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_metric_names() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> metric_names() const { return GetRepeated<::protozero::ConstChars>(1); }
  bool has_format() const { return at<2>().valid(); }
  int32_t format() const { return at<2>().as_int32(); }
};

class ComputeMetricArgs : public ::protozero::Message {
 public:
  using Decoder = ComputeMetricArgs_Decoder;
  enum : int32_t {
    kMetricNamesFieldNumber = 1,
    kFormatFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ComputeMetricArgs"; }

  using ResultFormat = ::perfetto::protos::pbzero::ComputeMetricArgs_ResultFormat;
  static const ResultFormat BINARY_PROTOBUF = ComputeMetricArgs_ResultFormat_BINARY_PROTOBUF;
  static const ResultFormat TEXTPROTO = ComputeMetricArgs_ResultFormat_TEXTPROTO;

  using FieldMetadata_MetricNames =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ComputeMetricArgs>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MetricNames kMetricNames() { return {}; }
  void add_metric_names(const char* data, size_t size) {
    AppendBytes(FieldMetadata_MetricNames::kFieldId, data, size);
  }
  void add_metric_names(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_MetricNames::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Format =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::ComputeMetricArgs_ResultFormat,
      ComputeMetricArgs>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Format kFormat() { return {}; }
  void set_format(::perfetto::protos::pbzero::ComputeMetricArgs_ResultFormat value) {
    static constexpr uint32_t field_id = FieldMetadata_Format::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class StatusResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  StatusResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit StatusResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit StatusResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_loaded_trace_name() const { return at<1>().valid(); }
  ::protozero::ConstChars loaded_trace_name() const { return at<1>().as_string(); }
  bool has_human_readable_version() const { return at<2>().valid(); }
  ::protozero::ConstChars human_readable_version() const { return at<2>().as_string(); }
  bool has_api_version() const { return at<3>().valid(); }
  int32_t api_version() const { return at<3>().as_int32(); }
};

class StatusResult : public ::protozero::Message {
 public:
  using Decoder = StatusResult_Decoder;
  enum : int32_t {
    kLoadedTraceNameFieldNumber = 1,
    kHumanReadableVersionFieldNumber = 2,
    kApiVersionFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.StatusResult"; }


  using FieldMetadata_LoadedTraceName =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      StatusResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LoadedTraceName kLoadedTraceName() { return {}; }
  void set_loaded_trace_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_LoadedTraceName::kFieldId, data, size);
  }
  void set_loaded_trace_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_LoadedTraceName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HumanReadableVersion =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      StatusResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_HumanReadableVersion kHumanReadableVersion() { return {}; }
  void set_human_readable_version(const char* data, size_t size) {
    AppendBytes(FieldMetadata_HumanReadableVersion::kFieldId, data, size);
  }
  void set_human_readable_version(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_HumanReadableVersion::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ApiVersion =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      StatusResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ApiVersion kApiVersion() { return {}; }
  void set_api_version(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ApiVersion::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class StatusArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  StatusArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit StatusArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit StatusArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class StatusArgs : public ::protozero::Message {
 public:
  using Decoder = StatusArgs_Decoder;
  static constexpr const char* GetName() { return ".perfetto.protos.StatusArgs"; }

};

class QueryResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  QueryResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit QueryResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit QueryResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_column_names() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> column_names() const { return GetRepeated<::protozero::ConstChars>(1); }
  bool has_error() const { return at<2>().valid(); }
  ::protozero::ConstChars error() const { return at<2>().as_string(); }
  bool has_batch() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> batch() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_statement_count() const { return at<4>().valid(); }
  uint32_t statement_count() const { return at<4>().as_uint32(); }
  bool has_statement_with_output_count() const { return at<5>().valid(); }
  uint32_t statement_with_output_count() const { return at<5>().as_uint32(); }
};

class QueryResult : public ::protozero::Message {
 public:
  using Decoder = QueryResult_Decoder;
  enum : int32_t {
    kColumnNamesFieldNumber = 1,
    kErrorFieldNumber = 2,
    kBatchFieldNumber = 3,
    kStatementCountFieldNumber = 4,
    kStatementWithOutputCountFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.QueryResult"; }

  using CellsBatch = ::perfetto::protos::pbzero::QueryResult_CellsBatch;

  using FieldMetadata_ColumnNames =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      QueryResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ColumnNames kColumnNames() { return {}; }
  void add_column_names(const char* data, size_t size) {
    AppendBytes(FieldMetadata_ColumnNames::kFieldId, data, size);
  }
  void add_column_names(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_ColumnNames::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Error =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      QueryResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Error kError() { return {}; }
  void set_error(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Error::kFieldId, data, size);
  }
  void set_error(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Error::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Batch =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      QueryResult_CellsBatch,
      QueryResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Batch kBatch() { return {}; }
  template <typename T = QueryResult_CellsBatch> T* add_batch() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_StatementCount =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      QueryResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_StatementCount kStatementCount() { return {}; }
  void set_statement_count(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_StatementCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StatementWithOutputCount =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint32,
      uint32_t,
      QueryResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_StatementWithOutputCount kStatementWithOutputCount() { return {}; }
  void set_statement_with_output_count(uint32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_StatementWithOutputCount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint32>
        ::Append(*this, field_id, value);
  }
};

class QueryResult_CellsBatch_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  QueryResult_CellsBatch_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit QueryResult_CellsBatch_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit QueryResult_CellsBatch_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cells() const { return at<1>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t> cells(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t>(1, parse_error_ptr); }
  bool has_varint_cells() const { return at<2>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t> varint_cells(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t>(2, parse_error_ptr); }
  bool has_float64_cells() const { return at<3>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kFixed64, double> float64_cells(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kFixed64, double>(3, parse_error_ptr); }
  bool has_blob_cells() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> blob_cells() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_string_cells() const { return at<5>().valid(); }
  ::protozero::ConstChars string_cells() const { return at<5>().as_string(); }
  bool has_is_last_batch() const { return at<6>().valid(); }
  bool is_last_batch() const { return at<6>().as_bool(); }
};

class QueryResult_CellsBatch : public ::protozero::Message {
 public:
  using Decoder = QueryResult_CellsBatch_Decoder;
  enum : int32_t {
    kCellsFieldNumber = 1,
    kVarintCellsFieldNumber = 2,
    kFloat64CellsFieldNumber = 3,
    kBlobCellsFieldNumber = 4,
    kStringCellsFieldNumber = 5,
    kIsLastBatchFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.QueryResult.CellsBatch"; }

  using CellType = ::perfetto::protos::pbzero::QueryResult_CellsBatch_CellType;
  static const CellType CELL_INVALID = QueryResult_CellsBatch_CellType_CELL_INVALID;
  static const CellType CELL_NULL = QueryResult_CellsBatch_CellType_CELL_NULL;
  static const CellType CELL_VARINT = QueryResult_CellsBatch_CellType_CELL_VARINT;
  static const CellType CELL_FLOAT64 = QueryResult_CellsBatch_CellType_CELL_FLOAT64;
  static const CellType CELL_STRING = QueryResult_CellsBatch_CellType_CELL_STRING;
  static const CellType CELL_BLOB = QueryResult_CellsBatch_CellType_CELL_BLOB;

  using FieldMetadata_Cells =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedPacked,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::QueryResult_CellsBatch_CellType,
      QueryResult_CellsBatch>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Cells kCells() { return {}; }
  void set_cells(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(FieldMetadata_Cells::kFieldId, packed_buffer.data(),
                packed_buffer.size());
  }

  using FieldMetadata_VarintCells =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedPacked,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      QueryResult_CellsBatch>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_VarintCells kVarintCells() { return {}; }
  void set_varint_cells(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(FieldMetadata_VarintCells::kFieldId, packed_buffer.data(),
                packed_buffer.size());
  }

  using FieldMetadata_Float64Cells =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedPacked,
      ::protozero::proto_utils::ProtoSchemaType::kDouble,
      double,
      QueryResult_CellsBatch>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Float64Cells kFloat64Cells() { return {}; }
  void set_float64_cells(const ::protozero::PackedFixedSizeInt<double>& packed_buffer) {
    AppendBytes(FieldMetadata_Float64Cells::kFieldId, packed_buffer.data(),
                packed_buffer.size());
  }

  using FieldMetadata_BlobCells =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      QueryResult_CellsBatch>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_BlobCells kBlobCells() { return {}; }
  void add_blob_cells(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_BlobCells::kFieldId, data, size);
  }
  void add_blob_cells(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_BlobCells::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StringCells =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      QueryResult_CellsBatch>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_StringCells kStringCells() { return {}; }
  void set_string_cells(const char* data, size_t size) {
    AppendBytes(FieldMetadata_StringCells::kFieldId, data, size);
  }
  void set_string_cells(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_StringCells::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsLastBatch =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      QueryResult_CellsBatch>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsLastBatch kIsLastBatch() { return {}; }
  void set_is_last_batch(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsLastBatch::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class RawQueryResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RawQueryResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RawQueryResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RawQueryResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_column_descriptors() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> column_descriptors() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_num_records() const { return at<2>().valid(); }
  uint64_t num_records() const { return at<2>().as_uint64(); }
  bool has_columns() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> columns() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_error() const { return at<4>().valid(); }
  ::protozero::ConstChars error() const { return at<4>().as_string(); }
  bool has_execution_time_ns() const { return at<5>().valid(); }
  uint64_t execution_time_ns() const { return at<5>().as_uint64(); }
};

class RawQueryResult : public ::protozero::Message {
 public:
  using Decoder = RawQueryResult_Decoder;
  enum : int32_t {
    kColumnDescriptorsFieldNumber = 1,
    kNumRecordsFieldNumber = 2,
    kColumnsFieldNumber = 3,
    kErrorFieldNumber = 4,
    kExecutionTimeNsFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RawQueryResult"; }

  using ColumnDesc = ::perfetto::protos::pbzero::RawQueryResult_ColumnDesc;
  using ColumnValues = ::perfetto::protos::pbzero::RawQueryResult_ColumnValues;

  using FieldMetadata_ColumnDescriptors =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RawQueryResult_ColumnDesc,
      RawQueryResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ColumnDescriptors kColumnDescriptors() { return {}; }
  template <typename T = RawQueryResult_ColumnDesc> T* add_column_descriptors() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_NumRecords =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      RawQueryResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_NumRecords kNumRecords() { return {}; }
  void set_num_records(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_NumRecords::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Columns =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RawQueryResult_ColumnValues,
      RawQueryResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Columns kColumns() { return {}; }
  template <typename T = RawQueryResult_ColumnValues> T* add_columns() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_Error =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      RawQueryResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Error kError() { return {}; }
  void set_error(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Error::kFieldId, data, size);
  }
  void set_error(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Error::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ExecutionTimeNs =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      RawQueryResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ExecutionTimeNs kExecutionTimeNs() { return {}; }
  void set_execution_time_ns(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ExecutionTimeNs::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }
};

class RawQueryResult_ColumnValues_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RawQueryResult_ColumnValues_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RawQueryResult_ColumnValues_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RawQueryResult_ColumnValues_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_long_values() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<int64_t> long_values() const { return GetRepeated<int64_t>(1); }
  bool has_double_values() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<double> double_values() const { return GetRepeated<double>(2); }
  bool has_string_values() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> string_values() const { return GetRepeated<::protozero::ConstChars>(3); }
  bool has_is_nulls() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<bool> is_nulls() const { return GetRepeated<bool>(4); }
};

class RawQueryResult_ColumnValues : public ::protozero::Message {
 public:
  using Decoder = RawQueryResult_ColumnValues_Decoder;
  enum : int32_t {
    kLongValuesFieldNumber = 1,
    kDoubleValuesFieldNumber = 2,
    kStringValuesFieldNumber = 3,
    kIsNullsFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RawQueryResult.ColumnValues"; }


  using FieldMetadata_LongValues =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      RawQueryResult_ColumnValues>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_LongValues kLongValues() { return {}; }
  void add_long_values(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LongValues::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DoubleValues =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kDouble,
      double,
      RawQueryResult_ColumnValues>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_DoubleValues kDoubleValues() { return {}; }
  void add_double_values(double value) {
    static constexpr uint32_t field_id = FieldMetadata_DoubleValues::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kDouble>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StringValues =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      RawQueryResult_ColumnValues>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_StringValues kStringValues() { return {}; }
  void add_string_values(const char* data, size_t size) {
    AppendBytes(FieldMetadata_StringValues::kFieldId, data, size);
  }
  void add_string_values(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_StringValues::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsNulls =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RawQueryResult_ColumnValues>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_IsNulls kIsNulls() { return {}; }
  void add_is_nulls(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsNulls::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class RawQueryResult_ColumnDesc_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RawQueryResult_ColumnDesc_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RawQueryResult_ColumnDesc_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RawQueryResult_ColumnDesc_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_type() const { return at<2>().valid(); }
  int32_t type() const { return at<2>().as_int32(); }
};

class RawQueryResult_ColumnDesc : public ::protozero::Message {
 public:
  using Decoder = RawQueryResult_ColumnDesc_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RawQueryResult.ColumnDesc"; }

  using Type = ::perfetto::protos::pbzero::RawQueryResult_ColumnDesc_Type;
  static const Type UNKNOWN = RawQueryResult_ColumnDesc_Type_UNKNOWN;
  static const Type LONG = RawQueryResult_ColumnDesc_Type_LONG;
  static const Type DOUBLE = RawQueryResult_ColumnDesc_Type_DOUBLE;
  static const Type STRING = RawQueryResult_ColumnDesc_Type_STRING;

  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      RawQueryResult_ColumnDesc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Name kName() { return {}; }
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Type =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::RawQueryResult_ColumnDesc_Type,
      RawQueryResult_ColumnDesc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Type kType() { return {}; }
  void set_type(::perfetto::protos::pbzero::RawQueryResult_ColumnDesc_Type value) {
    static constexpr uint32_t field_id = FieldMetadata_Type::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class RawQueryArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RawQueryArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RawQueryArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RawQueryArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_sql_query() const { return at<1>().valid(); }
  ::protozero::ConstChars sql_query() const { return at<1>().as_string(); }
};

class RawQueryArgs : public ::protozero::Message {
 public:
  using Decoder = RawQueryArgs_Decoder;
  enum : int32_t {
    kSqlQueryFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RawQueryArgs"; }


  using FieldMetadata_SqlQuery =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      RawQueryArgs>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SqlQuery kSqlQuery() { return {}; }
  void set_sql_query(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SqlQuery::kFieldId, data, size);
  }
  void set_sql_query(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SqlQuery::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class QueryArgs_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  QueryArgs_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit QueryArgs_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit QueryArgs_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_sql_query() const { return at<1>().valid(); }
  ::protozero::ConstChars sql_query() const { return at<1>().as_string(); }
};

class QueryArgs : public ::protozero::Message {
 public:
  using Decoder = QueryArgs_Decoder;
  enum : int32_t {
    kSqlQueryFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.QueryArgs"; }


  using FieldMetadata_SqlQuery =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      QueryArgs>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_SqlQuery kSqlQuery() { return {}; }
  void set_sql_query(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SqlQuery::kFieldId, data, size);
  }
  void set_sql_query(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SqlQuery::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class AppendTraceDataResult_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AppendTraceDataResult_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AppendTraceDataResult_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AppendTraceDataResult_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_total_bytes_parsed() const { return at<1>().valid(); }
  int64_t total_bytes_parsed() const { return at<1>().as_int64(); }
  bool has_error() const { return at<2>().valid(); }
  ::protozero::ConstChars error() const { return at<2>().as_string(); }
};

class AppendTraceDataResult : public ::protozero::Message {
 public:
  using Decoder = AppendTraceDataResult_Decoder;
  enum : int32_t {
    kTotalBytesParsedFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.AppendTraceDataResult"; }


  using FieldMetadata_TotalBytesParsed =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      AppendTraceDataResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_TotalBytesParsed kTotalBytesParsed() { return {}; }
  void set_total_bytes_parsed(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_TotalBytesParsed::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Error =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      AppendTraceDataResult>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Error kError() { return {}; }
  void set_error(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Error::kFieldId, data, size);
  }
  void set_error(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Error::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class TraceProcessorRpc_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/210, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceProcessorRpc_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceProcessorRpc_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceProcessorRpc_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_seq() const { return at<1>().valid(); }
  int64_t seq() const { return at<1>().as_int64(); }
  bool has_fatal_error() const { return at<5>().valid(); }
  ::protozero::ConstChars fatal_error() const { return at<5>().as_string(); }
  bool has_request() const { return at<2>().valid(); }
  int32_t request() const { return at<2>().as_int32(); }
  bool has_response() const { return at<3>().valid(); }
  int32_t response() const { return at<3>().as_int32(); }
  bool has_invalid_request() const { return at<4>().valid(); }
  int32_t invalid_request() const { return at<4>().as_int32(); }
  bool has_append_trace_data() const { return at<101>().valid(); }
  ::protozero::ConstBytes append_trace_data() const { return at<101>().as_bytes(); }
  bool has_query_args() const { return at<103>().valid(); }
  ::protozero::ConstBytes query_args() const { return at<103>().as_bytes(); }
  bool has_raw_query_args() const { return at<104>().valid(); }
  ::protozero::ConstBytes raw_query_args() const { return at<104>().as_bytes(); }
  bool has_compute_metric_args() const { return at<105>().valid(); }
  ::protozero::ConstBytes compute_metric_args() const { return at<105>().as_bytes(); }
  bool has_append_result() const { return at<201>().valid(); }
  ::protozero::ConstBytes append_result() const { return at<201>().as_bytes(); }
  bool has_query_result() const { return at<203>().valid(); }
  ::protozero::ConstBytes query_result() const { return at<203>().as_bytes(); }
  bool has_raw_query_result() const { return at<204>().valid(); }
  ::protozero::ConstBytes raw_query_result() const { return at<204>().as_bytes(); }
  bool has_metric_result() const { return at<205>().valid(); }
  ::protozero::ConstBytes metric_result() const { return at<205>().as_bytes(); }
  bool has_metric_descriptors() const { return at<206>().valid(); }
  ::protozero::ConstBytes metric_descriptors() const { return at<206>().as_bytes(); }
  bool has_metatrace() const { return at<209>().valid(); }
  ::protozero::ConstBytes metatrace() const { return at<209>().as_bytes(); }
  bool has_status() const { return at<210>().valid(); }
  ::protozero::ConstBytes status() const { return at<210>().as_bytes(); }
};

class TraceProcessorRpc : public ::protozero::Message {
 public:
  using Decoder = TraceProcessorRpc_Decoder;
  enum : int32_t {
    kSeqFieldNumber = 1,
    kFatalErrorFieldNumber = 5,
    kRequestFieldNumber = 2,
    kResponseFieldNumber = 3,
    kInvalidRequestFieldNumber = 4,
    kAppendTraceDataFieldNumber = 101,
    kQueryArgsFieldNumber = 103,
    kRawQueryArgsFieldNumber = 104,
    kComputeMetricArgsFieldNumber = 105,
    kAppendResultFieldNumber = 201,
    kQueryResultFieldNumber = 203,
    kRawQueryResultFieldNumber = 204,
    kMetricResultFieldNumber = 205,
    kMetricDescriptorsFieldNumber = 206,
    kMetatraceFieldNumber = 209,
    kStatusFieldNumber = 210,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TraceProcessorRpc"; }

  using TraceProcessorMethod = ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod;
  static const TraceProcessorMethod TPM_UNSPECIFIED = TraceProcessorRpc_TraceProcessorMethod_TPM_UNSPECIFIED;
  static const TraceProcessorMethod TPM_APPEND_TRACE_DATA = TraceProcessorRpc_TraceProcessorMethod_TPM_APPEND_TRACE_DATA;
  static const TraceProcessorMethod TPM_FINALIZE_TRACE_DATA = TraceProcessorRpc_TraceProcessorMethod_TPM_FINALIZE_TRACE_DATA;
  static const TraceProcessorMethod TPM_QUERY_STREAMING = TraceProcessorRpc_TraceProcessorMethod_TPM_QUERY_STREAMING;
  static const TraceProcessorMethod TPM_QUERY_RAW_DEPRECATED = TraceProcessorRpc_TraceProcessorMethod_TPM_QUERY_RAW_DEPRECATED;
  static const TraceProcessorMethod TPM_COMPUTE_METRIC = TraceProcessorRpc_TraceProcessorMethod_TPM_COMPUTE_METRIC;
  static const TraceProcessorMethod TPM_GET_METRIC_DESCRIPTORS = TraceProcessorRpc_TraceProcessorMethod_TPM_GET_METRIC_DESCRIPTORS;
  static const TraceProcessorMethod TPM_RESTORE_INITIAL_TABLES = TraceProcessorRpc_TraceProcessorMethod_TPM_RESTORE_INITIAL_TABLES;
  static const TraceProcessorMethod TPM_ENABLE_METATRACE = TraceProcessorRpc_TraceProcessorMethod_TPM_ENABLE_METATRACE;
  static const TraceProcessorMethod TPM_DISABLE_AND_READ_METATRACE = TraceProcessorRpc_TraceProcessorMethod_TPM_DISABLE_AND_READ_METATRACE;
  static const TraceProcessorMethod TPM_GET_STATUS = TraceProcessorRpc_TraceProcessorMethod_TPM_GET_STATUS;

  using FieldMetadata_Seq =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Seq kSeq() { return {}; }
  void set_seq(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Seq::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FatalError =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_FatalError kFatalError() { return {}; }
  void set_fatal_error(const char* data, size_t size) {
    AppendBytes(FieldMetadata_FatalError::kFieldId, data, size);
  }
  void set_fatal_error(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_FatalError::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Request =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Request kRequest() { return {}; }
  void set_request(::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod value) {
    static constexpr uint32_t field_id = FieldMetadata_Request::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Response =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Response kResponse() { return {}; }
  void set_response(::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod value) {
    static constexpr uint32_t field_id = FieldMetadata_Response::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InvalidRequest =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_InvalidRequest kInvalidRequest() { return {}; }
  void set_invalid_request(::perfetto::protos::pbzero::TraceProcessorRpc_TraceProcessorMethod value) {
    static constexpr uint32_t field_id = FieldMetadata_InvalidRequest::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AppendTraceData =
    ::protozero::proto_utils::FieldMetadata<
      101,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBytes,
      std::string,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AppendTraceData kAppendTraceData() { return {}; }
  void set_append_trace_data(const uint8_t* data, size_t size) {
    AppendBytes(FieldMetadata_AppendTraceData::kFieldId, data, size);
  }
  void set_append_trace_data(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_AppendTraceData::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBytes>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_QueryArgs =
    ::protozero::proto_utils::FieldMetadata<
      103,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      QueryArgs,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_QueryArgs kQueryArgs() { return {}; }
  template <typename T = QueryArgs> T* set_query_args() {
    return BeginNestedMessage<T>(103);
  }


  using FieldMetadata_RawQueryArgs =
    ::protozero::proto_utils::FieldMetadata<
      104,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RawQueryArgs,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RawQueryArgs kRawQueryArgs() { return {}; }
  template <typename T = RawQueryArgs> T* set_raw_query_args() {
    return BeginNestedMessage<T>(104);
  }


  using FieldMetadata_ComputeMetricArgs =
    ::protozero::proto_utils::FieldMetadata<
      105,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ComputeMetricArgs,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_ComputeMetricArgs kComputeMetricArgs() { return {}; }
  template <typename T = ComputeMetricArgs> T* set_compute_metric_args() {
    return BeginNestedMessage<T>(105);
  }


  using FieldMetadata_AppendResult =
    ::protozero::proto_utils::FieldMetadata<
      201,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AppendTraceDataResult,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_AppendResult kAppendResult() { return {}; }
  template <typename T = AppendTraceDataResult> T* set_append_result() {
    return BeginNestedMessage<T>(201);
  }


  using FieldMetadata_QueryResult =
    ::protozero::proto_utils::FieldMetadata<
      203,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      QueryResult,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_QueryResult kQueryResult() { return {}; }
  template <typename T = QueryResult> T* set_query_result() {
    return BeginNestedMessage<T>(203);
  }


  using FieldMetadata_RawQueryResult =
    ::protozero::proto_utils::FieldMetadata<
      204,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RawQueryResult,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_RawQueryResult kRawQueryResult() { return {}; }
  template <typename T = RawQueryResult> T* set_raw_query_result() {
    return BeginNestedMessage<T>(204);
  }


  using FieldMetadata_MetricResult =
    ::protozero::proto_utils::FieldMetadata<
      205,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ComputeMetricResult,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MetricResult kMetricResult() { return {}; }
  template <typename T = ComputeMetricResult> T* set_metric_result() {
    return BeginNestedMessage<T>(205);
  }


  using FieldMetadata_MetricDescriptors =
    ::protozero::proto_utils::FieldMetadata<
      206,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DescriptorSet,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_MetricDescriptors kMetricDescriptors() { return {}; }
  template <typename T = DescriptorSet> T* set_metric_descriptors() {
    return BeginNestedMessage<T>(206);
  }


  using FieldMetadata_Metatrace =
    ::protozero::proto_utils::FieldMetadata<
      209,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisableAndReadMetatraceResult,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Metatrace kMetatrace() { return {}; }
  template <typename T = DisableAndReadMetatraceResult> T* set_metatrace() {
    return BeginNestedMessage<T>(209);
  }


  using FieldMetadata_Status =
    ::protozero::proto_utils::FieldMetadata<
      210,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      StatusResult,
      TraceProcessorRpc>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Status kStatus() { return {}; }
  template <typename T = StatusResult> T* set_status() {
    return BeginNestedMessage<T>(210);
  }

};

class TraceProcessorRpcStream_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TraceProcessorRpcStream_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceProcessorRpcStream_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceProcessorRpcStream_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_msg() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> msg() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class TraceProcessorRpcStream : public ::protozero::Message {
 public:
  using Decoder = TraceProcessorRpcStream_Decoder;
  enum : int32_t {
    kMsgFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TraceProcessorRpcStream"; }


  using FieldMetadata_Msg =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TraceProcessorRpc,
      TraceProcessorRpcStream>;

  // Ceci n'est pas une pipe.
  // This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
  // type (and users are expected to use it as such, hence kCamelCase name).
  // It is declared as a function to keep protozero bindings header-only as
  // inline constexpr variables are not available until C++17 (while inline
  // functions are).
  // TODO(altimin): Use inline variable instead after adopting C++17.
  static constexpr FieldMetadata_Msg kMsg() { return {}; }
  template <typename T = TraceProcessorRpc> T* add_msg() {
    return BeginNestedMessage<T>(1);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
